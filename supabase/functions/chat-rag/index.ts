
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log('üîß [CHAT-RAG] Inicializando fun√ß√£o...');
    
    const supabaseUrl = Deno.env.get('SUPABASE_URL');
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
    
    if (!supabaseUrl || !supabaseKey) {
      console.error('‚ùå [CHAT-RAG] Vari√°veis de ambiente n√£o configuradas');
      throw new Error('Configura√ß√£o do servidor incompleta');
    }

    const supabaseClient = createClient(supabaseUrl, supabaseKey);
    console.log('‚úÖ [CHAT-RAG] Cliente Supabase criado');

    const requestBody = await req.json().catch(err => {
      console.error('‚ùå [CHAT-RAG] Erro ao ler body da requisi√ß√£o:', err);
      throw new Error('Formato de requisi√ß√£o inv√°lido');
    });

    const { message, conversationId, userId, sessionId, leadData, userProfile } = requestBody;
    
    console.log('üìù [CHAT-RAG] Dados recebidos:', {
      messageLength: message?.length || 0,
      conversationId: conversationId || 'novo',
      userId: userId || 'an√¥nimo',
      sessionId: sessionId || 'sem sess√£o',
      hasLeadData: !!leadData,
      hasUserProfile: !!userProfile,
      userName: userProfile?.display_name || 'N√£o informado'
    });
    
    if (!message || typeof message !== 'string' || !message.trim()) {
      throw new Error('Mensagem √© obrigat√≥ria e deve ser um texto v√°lido');
    }

    // Para usu√°rios an√¥nimos, usar sessionId
    if (!userId && !sessionId) {
      throw new Error('userId ou sessionId s√£o obrigat√≥rios');
    }

    console.log(`üöÄ [CHAT-RAG] Iniciando processamento para ${userId ? `usu√°rio ${userId}` : `sess√£o ${sessionId}`}`);

    let conversation = null
    
    // Usar perfil passado pelo frontend ou buscar no banco se necess√°rio
    let effectiveUserProfile = userProfile
    if (userId && !effectiveUserProfile) {
      console.log('[CHAT-RAG] Buscando perfil do usu√°rio no banco:', userId)
      const { data: profile, error: profileError } = await supabaseClient
        .from('community_profiles')
        .select('*')
        .eq('user_id', userId)
        .single()

      if (profileError) {
        console.log('[CHAT-RAG] Perfil n√£o encontrado ou erro:', profileError.message)
      } else {
        effectiveUserProfile = profile
        console.log('[CHAT-RAG] Perfil encontrado no banco:', profile.display_name)
      }
    } else if (effectiveUserProfile) {
      console.log('[CHAT-RAG] Usando perfil do frontend:', effectiveUserProfile.display_name)
    }

    // Se n√£o tiver conversationId, criar nova conversa
    if (!conversationId) {
      console.log('[CHAT-RAG] Criando nova conversa')
      
      // Gerar t√≠tulo mais inteligente baseado no perfil e mensagem
      let conversationTitle = message.substring(0, 50) + '...'
      if (effectiveUserProfile) {
        conversationTitle = `Conversa com ${effectiveUserProfile.display_name}`
      }
      
      const conversationData = {
        title: conversationTitle,
        message_count: 0,
        ...(userId ? { user_id: userId } : { session_id: sessionId })
      }
      
      const { data: newConversation, error: convError } = await supabaseClient
        .from('conversations')
        .insert(conversationData)
        .select()
        .single()

      if (convError) {
        throw new Error('Erro ao criar conversa: ' + convError.message)
      }
      
      conversation = newConversation
      
      // NOVO: Captura autom√°tica de lead para usu√°rios logados
      if (userId && effectiveUserProfile) {
        console.log('[CHAT-RAG] Verificando lead autom√°tico para usu√°rio logado')
        
        // Verificar se j√° existe lead para este usu√°rio
        const { data: existingLead, error: leadCheckError } = await supabaseClient
          .from('chat_leads')
          .select('*')
          .eq('email', effectiveUserProfile.user_id + '@user.local') // Email tempor√°rio baseado no user_id
          .single()

        if (leadCheckError && leadCheckError.code !== 'PGRST116') { // PGRST116 = not found
          console.error('[CHAT-RAG] Erro ao verificar lead existente:', leadCheckError)
        }

        if (!existingLead) {
          // Criar lead autom√°tico para usu√°rio logado
          console.log('[CHAT-RAG] Criando lead autom√°tico para usu√°rio logado')
          
          const { data: autoLead, error: autoLeadError } = await supabaseClient
            .from('chat_leads')
            .insert({
              name: effectiveUserProfile.display_name,
              email: effectiveUserProfile.user_id + '@user.local', // Email tempor√°rio
              phone: null,
              conversation_id: conversation.id,
              metadata: {
                source: 'auto_capture',
                type: 'logged_user',
                user_id: userId,
                first_message: message.substring(0, 100),
                user_agent: req.headers.get('user-agent') || 'unknown',
                grief_type: effectiveUserProfile.grief_type || null
              }
            })
            .select()
            .single()

          if (autoLeadError) {
            console.error('[CHAT-RAG] Erro ao criar lead autom√°tico:', autoLeadError)
          } else {
            // Atualizar conversa com o lead_id
            await supabaseClient
              .from('conversations')
              .update({ lead_id: autoLead.id })
              .eq('id', conversation.id)
            
            console.log(`[CHAT-RAG] Lead autom√°tico capturado: ${autoLead.id}`)
          }
        } else {
          // Lead j√° existe, apenas conectar √† conversa
          await supabaseClient
            .from('conversations')
            .update({ lead_id: existingLead.id })
            .eq('id', conversation.id)
          
          console.log(`[CHAT-RAG] Conversa conectada ao lead existente: ${existingLead.id}`)
        }
      }
      
      // Se temos dados de lead expl√≠citos, criar registro de lead
      if (leadData && leadData.name && leadData.email) {
        console.log('[CHAT-RAG] Salvando dados do lead expl√≠cito')
        
        // Verificar duplica√ß√£o por email
        const { data: existingEmailLead, error: emailCheckError } = await supabaseClient
          .from('chat_leads')
          .select('*')
          .eq('email', leadData.email)
          .single()

        if (emailCheckError && emailCheckError.code !== 'PGRST116') {
          console.error('[CHAT-RAG] Erro ao verificar lead por email:', emailCheckError)
        }

        if (!existingEmailLead) {
          const { data: chatLead, error: leadError } = await supabaseClient
            .from('chat_leads')
            .insert({
              name: leadData.name,
              email: leadData.email,
              phone: leadData.phone || null,
              conversation_id: conversation.id,
              metadata: {
                source: 'chat_modal',
                type: 'explicit_capture',
                first_message: message.substring(0, 100),
                user_agent: req.headers.get('user-agent') || 'unknown'
              }
            })
            .select()
            .single()

          if (leadError) {
            console.error('[CHAT-RAG] Erro ao salvar lead:', leadError)
          } else {
            // Atualizar conversa com o lead_id
            await supabaseClient
              .from('conversations')
              .update({ lead_id: chatLead.id })
              .eq('id', conversation.id)
            
            console.log(`[CHAT-RAG] Lead expl√≠cito capturado: ${chatLead.id}`)
          }
        } else {
          // Lead j√° existe, conectar √† conversa
          await supabaseClient
            .from('conversations')
            .update({ lead_id: existingEmailLead.id })
            .eq('id', conversation.id)
          
          console.log(`[CHAT-RAG] Conversa conectada ao lead existente: ${existingEmailLead.id}`)
        }
      }
    } else {
      // Buscar conversa existente
      const { data: existingConv, error: fetchError } = await supabaseClient
        .from('conversations')
        .select('*')
        .eq('id', conversationId)
        .single()

      if (fetchError) {
        throw new Error('Conversa n√£o encontrada')
      }

      conversation = existingConv
    }

    // NOVO: Buscar hist√≥rico de mensagens para contexto
    console.log('[CHAT-RAG] Buscando hist√≥rico de mensagens')
    const { data: messageHistory, error: historyError } = await supabaseClient
      .from('messages')
      .select('role, content')
      .eq('conversation_id', conversation.id)
      .order('created_at', { ascending: true })
      .limit(10) // √öltimas 10 mensagens para contexto

    if (historyError) {
      console.error('[CHAT-RAG] Erro ao buscar hist√≥rico:', historyError)
    }

    // Salvar mensagem do usu√°rio
    const { error: userMsgError } = await supabaseClient
      .from('messages')
      .insert({
        conversation_id: conversation.id,
        role: 'user',
        content: message
      })

    if (userMsgError) {
      console.error('[CHAT-RAG] Erro ao salvar mensagem do usu√°rio:', userMsgError)
    }

    // Buscar chunks relevantes usando a fun√ß√£o melhorada
    console.log('[CHAT-RAG] Buscando conhecimento relevante')
    
    const { data: relevantChunks, error: searchError } = await supabaseClient
      .rpc('search_knowledge_base', {
        search_query: message,
        limit_results: 5
      })

    if (searchError) {
      console.error('[CHAT-RAG] Erro na busca:', searchError)
    }

    console.log(`[CHAT-RAG] Encontrados ${relevantChunks?.length || 0} chunks relevantes`)

    // Buscar configura√ß√£o do agente
    const { data: agentConfig, error: configError } = await supabaseClient
      .from('agent_configs')
      .select('*')
      .eq('active', true)
      .single()

    if (configError) {
      console.error('[CHAT-RAG] Erro ao buscar configura√ß√£o do agente:', configError)
    }

    // Construir contexto melhorado para o GPT COM HIST√ìRICO E PERFIL
    let context = agentConfig?.system_prompt || `Voc√™ √© um assistente especializado em acolhimento emocional. 
    Sua fun√ß√£o √© oferecer suporte, orienta√ß√£o e informa√ß√µes √∫teis de forma emp√°tica e acolhedora.
    Sempre mantenha um tom respeitoso, compreensivo e humanizado em suas respostas.`
    
    // NOVO: Adicionar informa√ß√µes do perfil do usu√°rio ao contexto
    if (effectiveUserProfile) {
      context += '\n\n=== INFORMA√á√ïES DO USU√ÅRIO ===\n'
      context += `Nome: ${effectiveUserProfile.display_name}\n`
      if (effectiveUserProfile.bio) {
        context += `Bio: ${effectiveUserProfile.bio}\n`
      }
      if (effectiveUserProfile.grief_type) {
        context += `Tipo de luto: ${effectiveUserProfile.grief_type}\n`
      }
      context += `Usu√°rio an√¥nimo: ${effectiveUserProfile.is_anonymous ? 'Sim' : 'N√£o'}\n`
      context += '=== FIM DAS INFORMA√á√ïES DO USU√ÅRIO ===\n'
      context += `\nUse essas informa√ß√µes para personalizar suas respostas. Se o usu√°rio preferir anonimato, seja discreto. Adapte seu tom baseado no tipo de luto quando mencionado. Chame o usu√°rio pelo nome quando apropriado.\n`
    }
    
    // NOVO: Adicionar hist√≥rico de mensagens ao contexto
    if (messageHistory && messageHistory.length > 0) {
      context += '\n\n=== HIST√ìRICO DA CONVERSA ===\n'
      messageHistory.forEach((msg, index) => {
        const role = msg.role === 'user' ? 'Usu√°rio' : 'Assistente'
        context += `${role}: ${msg.content}\n`
      })
      context += '=== FIM DO HIST√ìRICO ===\n'
      context += '\nUse o hist√≥rico acima para manter a continuidade da conversa e lembrar-se do contexto anterior.\n'
    }
    
    if (relevantChunks && relevantChunks.length > 0) {
      context += '\n\n=== INFORMA√á√ïES DA BASE DE CONHECIMENTO ===\n'
      relevantChunks.forEach((chunk, index) => {
        context += `\n[Fonte ${index + 1}: ${chunk.document_name}]\n`
        context += `Resumo: ${chunk.chunk_summary || 'Conte√∫do sobre acolhimento'}\n`
        context += `Conte√∫do: ${chunk.chunk_text}\n`
        context += `Relev√¢ncia: ${(chunk.similarity_score * 100).toFixed(1)}%\n`
      })
      context += '\n=== FIM DAS INFORMA√á√ïES ===\n'
      context += '\n\nUse essas informa√ß√µes para fornecer respostas precisas e fundamentadas. Sempre cite as fontes quando utilizar informa√ß√µes espec√≠ficas da base de conhecimento.'
    }

    // Gerar resposta com OpenAI
    const openaiApiKey = Deno.env.get('OPENAI_API_KEY')
    let assistantResponse = ''
    let sources = []

    if (openaiApiKey) {
      console.log('[CHAT-RAG] Gerando resposta com OpenAI (com hist√≥rico)')
      
      try {
        // NOVO: Construir array de mensagens incluindo hist√≥rico
        const messages = [
          { role: 'system', content: context }
        ]
        
        // Adicionar hist√≥rico de mensagens
        if (messageHistory && messageHistory.length > 0) {
          messageHistory.forEach(msg => {
            messages.push({
              role: msg.role as 'user' | 'assistant',
              content: msg.content
            })
          })
        }
        
        // Adicionar mensagem atual
        messages.push({ role: 'user', content: message })

        const openaiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${openaiApiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: agentConfig?.model || 'gpt-4o-mini',
            messages: messages,
            temperature: agentConfig?.temperature || 0.7,
            max_tokens: agentConfig?.max_tokens || 1000,
          }),
        })

        if (!openaiResponse.ok) {
          const errorData = await openaiResponse.text()
          throw new Error(`OpenAI API Error: ${errorData}`)
        }

        const openaiData = await openaiResponse.json()
        assistantResponse = openaiData.choices[0]?.message?.content || 'Desculpe, n√£o consegui gerar uma resposta adequada.'
        
      } catch (error) {
        console.error('[CHAT-RAG] Erro na API OpenAI:', error)
        assistantResponse = 'Desculpe, estou enfrentando dificuldades t√©cnicas no momento. Tente novamente em alguns instantes.'
      }
      
      // Preparar fontes utilizadas
      if (relevantChunks && relevantChunks.length > 0) {
        sources = relevantChunks.map(chunk => ({
          documentName: chunk.document_name || 'Documento',
          documentId: chunk.document_id,
          chunkText: chunk.chunk_text.substring(0, 200) + '...',
          summary: chunk.chunk_summary,
          relevanceScore: Math.round(chunk.similarity_score * 100)
        }))
      }
    } else {
      console.log('[CHAT-RAG] Usando resposta simulada (sem OpenAI API Key)')
      
      assistantResponse = `Compreendo sua mensagem: "${message}". ` +
        `Como assistente de acolhimento, estou aqui para oferecer suporte emocional personalizado. `
      
      // Mencionar continuidade se houver hist√≥rico
      if (messageHistory && messageHistory.length > 0) {
        assistantResponse += `\n\nLembro-me de nossa conversa anterior e posso continuar de onde paramos. `
      }
      
      if (relevantChunks && relevantChunks.length > 0) {
        assistantResponse += `\n\nBaseado nas informa√ß√µes da nossa base de conhecimento, posso compartilhar algumas orienta√ß√µes relevantes:\n\n`
        
        relevantChunks.slice(0, 2).forEach((chunk, index) => {
          assistantResponse += `${index + 1}. ${chunk.chunk_summary || 'Informa√ß√£o sobre acolhimento'}\n`
        })
        
        sources = relevantChunks.map(chunk => ({
          documentName: chunk.document_name || 'Documento',
          documentId: chunk.document_id,
          chunkText: chunk.chunk_text.substring(0, 200) + '...',
          summary: chunk.chunk_summary,
          relevanceScore: Math.round(chunk.similarity_score * 100)
        }))
      } else {
        assistantResponse += `\n\nEmbora n√£o tenha encontrado informa√ß√µes espec√≠ficas em nossa base de conhecimento para sua consulta, posso oferecer suporte geral e orienta√ß√µes baseadas em boas pr√°ticas de acolhimento.`
      }
    }

    // Salvar resposta do assistente
    const { error: assistantMsgError } = await supabaseClient
      .from('messages')
      .insert({
        conversation_id: conversation.id,
        role: 'assistant',
        content: assistantResponse,
        sources: sources,
        metadata: {
          chunks_used: relevantChunks?.length || 0,
          model_used: agentConfig?.model || 'gpt-4o-mini',
          has_api_key: !!openaiApiKey,
          has_history: !!(messageHistory && messageHistory.length > 0)
        }
      })

    if (assistantMsgError) {
      console.error('[CHAT-RAG] Erro ao salvar resposta do assistente:', assistantMsgError)
    }

    // Atualizar contador de mensagens na conversa
    const { error: updateConvError } = await supabaseClient
      .from('conversations')
      .update({ 
        message_count: conversation.message_count + 2,
        last_message_at: new Date().toISOString()
      })
      .eq('id', conversation.id)

    if (updateConvError) {
      console.error('[CHAT-RAG] Erro ao atualizar conversa:', updateConvError)
    }

    console.log(`‚úÖ [CHAT-RAG] Chat conclu√≠do para conversa ${conversation.id} ${messageHistory?.length ? 'com hist√≥rico' : 'sem hist√≥rico'}`);

    const successResponse = {
      success: true,
      conversationId: conversation.id,
      response: assistantResponse,
      sources: sources,
      chunks_found: relevantChunks?.length || 0,
      lead_captured: !!(leadData && leadData.name && leadData.email),
      has_history: !!(messageHistory && messageHistory.length > 0)
    };

    console.log('üì§ [CHAT-RAG] Enviando resposta de sucesso:', {
      conversationId: successResponse.conversationId,
      responseLength: assistantResponse.length,
      sourcesCount: sources.length,
      chunks_found: successResponse.chunks_found
    });

    return new Response(
      JSON.stringify(successResponse),
      { 
        headers: { 
          'Content-Type': 'application/json',
          ...corsHeaders 
        } 
      }
    )

  } catch (error) {
    console.error('üí• [CHAT-RAG] Erro cr√≠tico no chat RAG:', error);
    
    const errorResponse = {
      success: false,
      error: error instanceof Error ? error.message : 'Erro interno do servidor',
      details: 'Verifique os logs da fun√ß√£o para mais detalhes',
      timestamp: new Date().toISOString()
    };

    console.log('üì§ [CHAT-RAG] Enviando resposta de erro:', errorResponse);

    return new Response(
      JSON.stringify(errorResponse),
      { 
        status: 500,
        headers: { 
          'Content-Type': 'application/json',
          ...corsHeaders 
        } 
      }
    )
  }
})
